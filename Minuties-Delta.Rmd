---
title: "Minuties-Delta"
header-includes:
- \usepackage{pdflscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
output: pdf_document

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## The data

100 fingerprint cards were choosen in order to get both thumbs having ulnar loops with at least 20 ridges between the delta and the core of the loop. The same was made to get cards with the clean delta and a control zone on each of the palms. The control zone was defined as a zone were the flow of the ridge is straight and parrallel situated in the thenar zone, just over the thumb.

These different zones were extracted and croped with a 3 x 3 cm square. The part containing a delta were centered on it and the upper axis was placed north. For the control zone, the square was aligned with the edge of the print and the upper part on the middle line.

For each image the minutiaes were annotated with their position and the orientation. These are represented in the plots separated by zones and hand.


```{r load Data, echo=FALSE, include=FALSE, warning=FALSE}
# Préparation des données avec séparations entre deltas propre, de pouce et zone de controle----

data = read.csv( paste(getwd(), "/data_all.csv",sep="" )) ## 48434 obs, 16 var

library(ggplot2)
library(dplyr) # mutate
library(mosaic) # rad2deg
library(spatstat) # ppp, Kest
library(gridExtra) # tableGrob


data = mutate( data, xc = x.minut - x.centre )
data = mutate( data, yc = y.minut - y.centre ) 
data = mutate( data, angle.correction = rad2deg(angle.correction))
data = mutate( data, t.minut=(t.minut+180)%%360)
data = mutate( data, tc = t.minut - angle.correction)
data = mutate( data, angle.bc = ((360-angle.b)-(360-angle.c)))
data = mutate( data, theta = tc - phi) #nouveau: est adapté à l'angle de position de la minutie

for (i in 1:nrow(data)) {
  if (data[i,20] < 0) {
    data[i,20] = data[i,20] + 360 
  } 
  if (data[i,16] < 0){
    data[i,16] = data[i,16] + 360
  }
}

pouceD = subset(data, type=="delta de pouce" & d.g=="droit")
pouceG = subset(data, type=="delta de pouce" & d.g=="gauche")
propreD = subset(data, type=="delta propre" & d.g=="droit")
propreG = subset(data, type=="delta propre" & d.g=="gauche")
controlD = subset(data, type=="zone de controle" & d.g=="droit")
controlG = subset(data, type=="zone de controle" & d.g=="gauche")

```


```{r plot data full, echo=FALSE, warning=FALSE}
# Préparation des données avec séparations entre deltas propre, de pouce et zone de controle----

ppouceDd15 = ppp(pouceD[,17],pouceD[,18], disc(7.5)) ; ppouceGd15 = ppp(pouceG[,17],pouceG[,18], disc(7.5))
ppropreDd15 = ppp(propreD[,17],propreD[,18], disc(7.5)) ; ppropreGd15 = ppp(propreG[,17],propreG[,18], disc(7.5))
pcontrolDd15 = ppp(controlD[,17],controlD[,18], disc(7.5)) ; pcontrolGd15 = ppp(controlG[,17],controlG[,18], disc(7.5))

layout(matrix(c(1,2,3,4,5,6),nrow=2,ncol=3))
par(oma = c(0,5,0,0) + 0.1,mar = c(0,0,0.9,0) + 0.1)
plot(ppouceDd15,main="Thumb delta",cex.main=1, ylab="RIGHT", border=rgb(0,1,0))
plot(ppouceGd15,main="", border=rgb(0,1,0)) 
plot(ppropreDd15,main="Clean delta", border=rgb(0,1,0));plot(ppropreGd15,main="", border=rgb(0,1,0))
plot(pcontrolDd15,main="Control zone", border=rgb(0,1,0));plot(pcontrolGd15,main="", border=rgb(0,1,0))
title("", cex.main=2, outer=TRUE, font.lab=2, ylab="Left Hand                                      Right Hand",cex.lab=1.2)

```

The green circle is the window in which the analysis will be made. The diameter is of 1.5 cm which allows to avoid the problem of edge effects. The points out of this window won't be used for the analysis.

\newpage

## CSR testing

A CSR test (Complete Spatial Randomness) was done on each print individually. This was made using a second order K test accordingly to what was done in Chen and Moon 2006. 

```{r plot CSR, echo=FALSE, warning=FALSE, fig.height=1.11, fig.width=2.95, fig.align="center", fig.show="hold"}
CSR <- function(data,name, plot = TRUE, summary = TRUE){
  r<- seq(0,7.5, by=0.01) ; CSR=0 ; cluster = 0 ; dispersed = 0 ; cluster2 = 0 ; dispersed2 = 0 ; test = data.frame()
  
  for (i in unique(data[,1])){
    datau = data.frame()
    for (j in 1:nrow(data)){
      if (data[j,1] == i){datau=rbind(datau,data[j,])}}
    ppp = ppp(datau[,17],datau[,18],disc(7.5))
    k=Kest(ppp,correction="Ripley",var.approx = TRUE,ratio= TRUE)
    
    n=1 ; d=0 ; c=0 ; csr=0 ; d2=0 ; c2=0
    for (r in k$r) {
      if (k$iso[n] - pi * r^2 < -2*sqrt(k$rip[n])) {d=d+1}
      else if (k$iso[n] - pi * r^2 > 2*sqrt(k$rip[n])) {c=c+1}
      else csr=csr+1
      
      if (k$iso[n] - pi * r^2 < -2*sqrt(k$rip[n]) & k$r[n]>2.5) {d2=d2+1}
      else if (k$iso[n] - pi * r^2 > 2*sqrt(k$rip[n]) & k$r[n]>2.5) {c2=c2+1}
      
      n=n+1
      if (csr==length(k$r)){CSR=CSR+1}
    }
    
    test=rbind(test,c(i,round(d/length(k$r)*100,1),round(csr/length(k$r)*100,1),round(c/length(k$r)*100,1)))
    if (c>d){cluster=cluster + 1}
    else if (c<d){dispersed=dispersed+1}
    
    if (c2>d2){cluster2=cluster2 + 1}
    else if (c2<d2){dispersed2=dispersed2+1}
  
  
  if (plot) {
    layout(matrix(c(seq(1,9,2),seq(2,10,2),seq(11,19,2),seq(12,20,2),seq(21,29,2),seq(22,30,2),seq(31,39,2),seq(32,40,2)),nrow=5,ncol=8))
    par(oma=c(0,0,1.5,0)+0.1,mar=c(2,1.5,1,0)+0.1)
    plot(ppp,main=i,cex=0.5)
    
    # c(-ceiling(max(c(2*sqrt(k$rip),k$t-pi * k$r^2))),ceiling(max(c(2*sqrt(k$rip),k$t-pi * k$r^2))))
    plot(k,. - pi * r^2 ~ r,ylim=c(-15,15),main="",ylab="",xlab="",legend=FALSE)
    lines(matrix(c(k$r,2*sqrt(k$rip)),ncol=2),lty=2,col="red") ; lines(matrix(c(k$r,-2*sqrt(k$rip)),ncol=2),lty=2,col="red")
    # mtext(name, outer=TRUE,  cex=1, line=0)
    }
    }
  
  if (summary){
    colnames(test)=c("ID","Dis", "CSR", "Clu")
  
    mytheme <- gridExtra::ttheme_default(
      core = list(fg_params=list(cex = 0.75)),
      colhead = list(fg_params=list(cex = 1.0)),
      rowhead = list(fg_params=list(cex = 1.0)))
  
    t1=tableGrob(test[seq(1,20),],rows=NULL, theme = mytheme)
    t2=tableGrob(test[seq(21,40),],rows=NULL, theme = mytheme)
    t3=tableGrob(test[seq(41,60),],rows=NULL, theme = mytheme)
    t4=tableGrob(test[seq(61,80),],rows=NULL, theme = mytheme)
    t5=tableGrob(test[seq(81,100),],rows=NULL, theme = mytheme)
    grid.arrange(t1,t2,t3,t4,t5, ncol=5)
    
    # mtext(name, outer=TRUE,  cex=1, line=-0)
  }
  
  return (c(CSR,dispersed2,cluster2,dispersed,cluster))
  
  # mtext(name, outer=TRUE,  cex=1, line=-0)
  # mtext(paste(CSR," total CSR distributions, ",cluster," clustering and ",dispersed," dispersed",sep=""),outer = TRUE, cex=1,line=-52)
  # mtext(paste("Over 2.5 mm, ",cluster2," clustering and ",dispersed2," dispersed",sep=""),outer = TRUE, cex=1,line=-54)
  
}


datapouced = CSR(pouceD,"PouceD",plot=FALSE, summary=FALSE) # 17
datapouceg = CSR(pouceG,"PouceG",plot=FALSE, summary=FALSE) # 7
datapropred = CSR(propreD,"PropreD",plot=FALSE, summary=FALSE) # 29
datapropreg = CSR(propreG,"PropreG",plot=FALSE, summary=FALSE) # 24
datacontrold = CSR(controlD,"ControlD",plot=FALSE, summary=FALSE) # 69
datacontrolg = CSR(controlG,"ControlG",plot=FALSE, summary=FALSE) # 74
print(datapouced) ; print(datapouceg) ; print(datapropred) ; print(datapropreg) ; print(datacontrold) ; print(datacontrolg)

datafin=as.data.frame(matrix(0, ncol = 4, nrow = 3))

datafin[1,2] = datapouced[1] ; datafin[1,3] = datapouceg[1]
datafin[2,2] = datapropred[1] ; datafin[2,3] = datapropreg[1]
datafin[3,2] = datacontrold[1] ; datafin[3,3] = datacontrolg[1]

datafin[1,4] = paste((datafin[1,2]+datafin[1,3]), " (", ((datafin[1,2]+datafin[1,3])/2)," %)",sep="")
datafin[2,4] = paste((datafin[2,2]+datafin[2,3]), " (", ((datafin[2,2]+datafin[2,3])/2)," %)",sep="")
datafin[3,4] = paste((datafin[3,2]+datafin[3,3]), " (", ((datafin[3,2]+datafin[3,3])/2)," %)",sep="")
colnames(datafin) = c("", "Droit", "Gauche", "total (%)") ; datafin[1,1] = "Pouce" ; datafin[2,1] = "Propre" ; datafin[3,1] = "Control"

datafin2=as.data.frame(matrix(0, ncol = 4, nrow = 3))

datafin2[1,2] = (100 - (datapouced[2] + datapouced[3]))     ; datafin2[1,3] = (100 - (datapouceg[2] + datapouceg[3]))
datafin2[2,2] = (100 - (datapropred[2] + datapropred[3]))   ; datafin2[2,3] = (100 - (datapropreg[2] + datapropreg[3]))
datafin2[3,2] = (100 - (datacontrold[2] + datacontrold[3])) ; datafin2[3,3] = (100 - (datacontrolg[2] + datacontrolg[3]))

datafin2[1,4] = paste((datafin2[1,2]+datafin2[1,3]), " (", ((datafin2[1,2]+datafin2[1,3])/2)," %)",sep="")
datafin2[2,4] = paste((datafin2[2,2]+datafin2[2,3]), " (", ((datafin2[2,2]+datafin2[2,3])/2)," %)",sep="")
datafin2[3,4] = paste((datafin2[3,2]+datafin2[3,3]), " (", ((datafin2[3,2]+datafin2[3,3])/2)," %)",sep="")
colnames(datafin2) = c("", "Droit", "Gauche", "total (%)") ; datafin2[1,1] = "Pouce" ; datafin2[2,1] = "Propre" ; datafin2[3,1] = "Control"

plot(tableGrob(datafin,rows=NULL))
plot(tableGrob(datafin2,rows=NULL))
```

```{r plot Disp/Clust, echo=FALSE, warning=FALSE, fig.height=1.11, fig.width=4, fig.align="center", fig.show="hold"}

datafin3=as.data.frame(matrix(0, ncol = 4, nrow = 3))

datafin3[1,2] = paste(datapouced[4]," / ",datapouced[5]) ; datafin3[1,3] = paste(datapouceg[4]," / ",datapouceg[5])
datafin3[2,2] = paste(datapropred[4]," / ",datapropred[5]) ; datafin3[2,3] = paste(datapropreg[4]," / ",datapropreg[5])
datafin3[3,2] = paste(datacontrold[4]," / ",datacontrold[5]) ; datafin3[3,3] = paste(datacontrolg[4]," / ",datacontrolg[5])

datafin3[1,4] = paste(((datapouced[4]+datapouceg[4])/2), " / ", paste(((datapouced[5]+datapouceg[5])/2), 
                                                                      " (", ((datapouced[4]+datapouceg[4])/2), " % / ", ((datapouced[5]+datapouceg[5])/2)," %)",sep=""))
datafin3[2,4] = paste(((datapropred[4]+datapropreg[4])/2), " / ", paste(((datapropred[5]+datapropreg[5])/2),
                                                                        " (", ((datapropred[4]+datapropreg[4])/2), " % / ", ((datapropred[5]+datapropreg[5])/2)," %)",sep=""))
datafin3[3,4] = paste(((datacontrold[4]+datacontrolg[4])/2), " / ", paste(((datacontrold[5]+datacontrolg[5])/2),
                                                                        " (", ((datacontrold[4]+datacontrolg[4])/2), " % / ", ((datacontrold[5]+datacontrolg[5])/2)," %)",sep=""))
colnames(datafin3) = c("", "Droit", "Gauche", "total (%)") ; datafin3[1,1] = "Pouce" ; datafin3[2,1] = "Propre" ; datafin3[3,1] = "Control"

datafin4=as.data.frame(matrix(0, ncol = 4, nrow = 3))

datafin4[1,2] = paste(datapouced[2]," / ",datapouced[3]) ; datafin4[1,3] = paste(datapouceg[2]," / ",datapouceg[3])
datafin4[2,2] = paste(datapropred[2]," / ",datapropred[3]) ; datafin4[2,3] = paste(datapropreg[2]," / ",datapropreg[3])
datafin4[3,2] = paste(datacontrold[2]," / ",datacontrold[3]) ; datafin4[3,3] = paste(datacontrolg[2]," / ",datacontrolg[3])

datafin4[1,4] = paste(((datapouced[2]+datapouceg[2])/2), " / ", paste(((datapouced[3]+datapouceg[3])/2), 
                    " (", ((datapouced[2]+datapouceg[2])/2), " % / ", ((datapouced[3]+datapouceg[3])/2)," %)",sep=""))
datafin4[2,4] = paste(((datapropred[2]+datapropreg[2])/2), " / ", paste(((datapropred[3]+datapropreg[3])/2),
                    " (", ((datapropred[2]+datapropreg[2])/2), " % / ", ((datapropred[3]+datapropreg[3])/2)," %)",sep=""))
datafin4[3,4] = paste(((datacontrold[2]+datacontrolg[2])/2), " / ", paste(((datacontrold[5]+datacontrolg[5])/2),
                    " (", ((datacontrold[2]+datacontrolg[2])/2), " % / ", ((datacontrold[3]+datacontrolg[3])/2)," %)",sep=""))
colnames(datafin4) = c("", "Droit", "Gauche", "total (%)") ; datafin4[1,1] = "Pouce" ; datafin4[2,1] = "Propre" ; datafin4[3,1] = "Control"

plot(tableGrob(datafin3,rows=NULL))
plot(tableGrob(datafin4,rows=NULL))
```

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
